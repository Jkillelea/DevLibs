
/**
 *  @brief:  Implementation of a RFM69 platform dependent [STM32 CUBE LL] radio functions
 *  @author: luk6xff
 *  @email:  lukasz.uszko@gmail.com
 *  @date:   2020-01-11
 */

#include "rfm69-cube-ll.h"
#include "main.h"

//-----------------------------------------------------------------------------
static uint8_t spi_transfer_byte_helper(SPI_TypeDef* spi, uint8_t byte)
{
    uint16_t spi_timeout = 1000;
	LL_SPI_TransmitData8(spi, byte);
	while (!LL_SPI_IsActiveFlag_TXE(spi))
	{
		if (spi_timeout-- == 0)
		{
			goto err;
		}
	}

	spi_timeout = 1000;
	while (!LL_SPI_IsActiveFlag_RXNE(spi))
	{
		if (spi_timeout-- == 0)
		{
			goto err;
		}
	}

	return LL_SPI_ReceiveData8(spi);

err:
	return 0xFF;
}

//-----------------------------------------------------------------------------
void rfm69_cube_init(rfm69* const dev, rfm69_cube* const cube_dev)
{
    dev->platform_dev = cube_dev;

    rfm69_init(dev);
}

//-----------------------------------------------------------------------------
void rfm69_cube_deinit(rfm69* const dev)
{
    rfm69_sleep(dev);
}

//-----------------------------------------------------------------------------
void rfm69_io_init(rfm69* const dev)
{
    (void*)dev;
    // Init SPI
    // SPI already configured in MX_SPIx_Init - generated by cube
}

//-----------------------------------------------------------------------------
void rfm69_io_deinit(rfm69* const dev)
{
    rfm69_cube* const pd = (rfm69_cube*)dev->platform_dev;
    LL_GPIO_SetOutputPin(pd->reset_port, pd->reset_pin);
}


//-----------------------------------------------------------------------------
void rfm69_ioirq_init(rfm69* const dev)
{
    (void*)dev;
    // dio0 HAL_GPIO_EXTI_Callback must be reimplemented in the main and shall
    // 				 contain a call the proper rfm69 isr handler function
}

//-----------------------------------------------------------------------------
void rfm69_reset(rfm69* const dev)
{
    rfm69_cube* const pd = (rfm69_cube*)dev->platform_dev;
    LL_GPIO_SetOutputPin(pd->reset_port, pd->reset_pin);
    rfm69_delay_ms(10);
    LL_GPIO_ResetOutputPin(pd->reset_port, pd->reset_pin);
    rfm69_delay_ms(10);
}

//-----------------------------------------------------------------------------
void rfm69_write_buffer(rfm69* const dev, uint8_t addr, const uint8_t *buffer, uint8_t size)
{
    rfm69_cube* const pd = (rfm69_cube*)dev->platform_dev;

    uint8_t address = (addr | 0x80);
    // Enable SPI
    LL_SPI_Enable(pd->spi);
    // NSS pin to LOW
    LL_GPIO_ResetOutputPin(pd->nss_port, pd->nss_pin);
    ///> Send address value
    spi_transfer_byte_helper(pd->spi, address);

	///> Send data buffer
	for(uint8_t i=0; i<size; i++)
	{
		spi_transfer_byte_helper(pd->spi, buffer[i]);
	}
    // NSS pin to HIGH
	LL_GPIO_SetOutputPin(pd->nss_port, pd->nss_pin);
    // Disable SPI
    LL_SPI_Disable(pd->spi);
}

//-----------------------------------------------------------------------------
void rfm69_read_buffer(rfm69* const dev, uint8_t addr, uint8_t *buffer, uint8_t size)
{
    rfm69_cube* const pd = (rfm69_cube*)dev->platform_dev;

    uint8_t address = (addr & 0x7F);
    // Enable SPI
    LL_SPI_Enable(pd->spi);

    // NSS pin to LOW
    LL_GPIO_ResetOutputPin(pd->nss_port, pd->nss_pin);

    ///> Send address value
    spi_transfer_byte_helper(pd->spi, address);
	///> Receive data buffer
	for(uint8_t i=0; i<size; i++)
	{
	    ///> Send address value
	    //spi_transfer_byte_helper(pd->spi, 0x00);
		///> Receive byte
		buffer[i] = spi_transfer_byte_helper(pd->spi, 0x00);
	}

	// NSS pin to HIGH
	LL_GPIO_SetOutputPin(pd->nss_port, pd->nss_pin);
    // Disable SPI
    LL_SPI_Disable(pd->spi);
}

//-----------------------------------------------------------------------------
void rfm69_delay_ms(int delay_ms)
{
	LL_mDelay(delay_ms);
}

//-----------------------------------------------------------------------------
uint32_t rfm69_timer_read_ms()
{
	// tick_ms var incremented in void SysTick_Handler(void)
    return tick_ms;
}

//-----------------------------------------------------------------------------
#include <stdio.h>
void rfm69_print_all_regs(rfm69* const dev)
{
    uint8_t reg_val;
    //printf("\r\n<<<RFM69 REGISTERS>>>\r\nADDR - HEX\r\n");
    for (uint8_t reg_addr = 1; reg_addr <= 0x71; reg_addr++)
    {
        reg_val = rfm69_read_reg(dev, reg_addr);
        printf("0x%x", reg_addr);
        printf(" - ");
        printf("0x%x\r\n", reg_val);
    }
}

//-----------------------------------------------------------------------------
